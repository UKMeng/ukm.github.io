<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>PAT 1003 Emergency (25 分)</title>
      <link href="2021/03/PAT-1003-Emergency-25-%E5%88%86/"/>
      <url>2021/03/PAT-1003-Emergency-25-%E5%88%86/</url>
      
        <content type="html"><![CDATA[<blockquote><p>封面出处：<a href="https://www.pixiv.net/artworks/88377350">https://www.pixiv.net/artworks/88377350</a></p></blockquote><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><blockquote><p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805523835109376">1003 Emergency (25 分)</a></p></blockquote><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给一个无向图，给定起点和终点，计算从起点到终点的最短路径的数量，以及这些路径中点的资源（救援队）和的最大值。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="Dijkstra-Algotirthm"><a href="#Dijkstra-Algotirthm" class="headerlink" title="Dijkstra Algotirthm"></a>Dijkstra Algotirthm</h3><ol><li>在Dijsktra算法中对从起点到各点的距离、最短距离的路径数、最大资源数进行更新统计</li><li>如果起点到某一点的距离更新了最小值，那么需要重新记录路径数和最大资源数</li><li>如果起点到某一点的距离没有更新，则累加路径数，并比较是否由更大的资源数，如果有则更新</li></ol><h3 id="DFS-Backtracking"><a href="#DFS-Backtracking" class="headerlink" title="DFS + Backtracking"></a>DFS + Backtracking</h3><ol><li>从起点进行DFS到终点</li><li>到终点时按要求比较和更新距离、路径数和资源数</li><li>回溯重新进行遍历寻找新路径</li></ol><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;vector&lt;int&gt; weight;// dijkstravoid dijkstra(int start, int end, vector&lt;int&gt; weight, vector&lt;vector&lt;int&gt;&gt; G, int&amp; count, int&amp; max_res){    int n = weight.size();    vector&lt;bool&gt; visit(n);    vector&lt;int&gt; dis(n, 0x3f3f3f3f);    vector&lt;int&gt; res(n);    vector&lt;int&gt; path_num(n);    dis[start] = 0;    res[start] = weight[start];    path_num[start] = 1;    for(int i = 0; i &lt; n; i++){        int MIN_DIS = 0x3f3f3f3f;        int u = -1;        for(int j = 0; j &lt; n; j++){            if(!visit[j] &amp;&amp; dis[j] &lt; MIN_DIS){                u = j;                MIN_DIS = dis[j];            }        }        if(u == -1) return;        visit[u] = true;        for(int v = 0; v &lt; n; v++){            if(!visit[v] &amp;&amp; G[u][v] != 0){                if(dis[v] &gt; dis[u] + G[u][v]){                    dis[v] = dis[u] + G[u][v];                    res[v] = weight[v] + res[u];                    path_num[v] = path_num[u];                } else if(dis[v] == dis[u] + G[u][v]){                    res[v] = max(res[v], weight[v] + res[u]);                    path_num[v] += path_num[u];                }            }        }    }    count = path_num[end];    max_res = res[end];    return;}// dfsvector&lt;vector&lt;pair&lt;int, int&gt;&gt;&gt; edge;vector&lt;bool&gt; visit_dfs;int temp_res = 0;int temp_dis = 0;int min_temp_dis = 0x3f3f3f3f;void dfs(int start, int end, int&amp; count, int&amp; max_res){    if(start == end){        temp_res += weight[end];        if(temp_dis &lt; min_temp_dis){            min_temp_dis = temp_dis;            count = 1;            max_res = temp_res;        } else if(temp_dis == min_temp_dis){            count++;            max_res = max(max_res, temp_res);        }        temp_res -= weight[end];        return;    }    for(int i = 0; i &lt; edge[start].size(); i++){        int v = edge[start][i].first;        int dis = edge[start][i].second;        if(!visit_dfs[v]){            visit_dfs[start] = true;            temp_res += weight[start];            temp_dis += dis;            dfs(v, end, count, max_res);            visit_dfs[start] = false;            temp_res -= weight[start];            temp_dis -= dis;        }    }}int main(){    int n, m, start, end;    int count = 0; // 记录最短路径数量    int max_res = 0; // 记录最大救援队数量    cin &gt;&gt; n &gt;&gt; m &gt;&gt; start &gt;&gt; end;    weight.resize(n);    edge.resize(n);    visit_dfs.resize(n);    vector&lt;vector&lt;int&gt;&gt; G(n, weight);    for(int i = 0; i &lt; n; i++){        cin &gt;&gt; weight[i];    }    for(int i = 0; i &lt; m; i++){        int a, b, w;        cin &gt;&gt; a &gt;&gt; b &gt;&gt; w;        G[a][b] = w;        G[b][a] = w;        edge[a].push_back({b,w});        edge[b].push_back({a,w});    }    dijkstra(start, end, weight, G, count, max_res);    cout &lt;&lt; "dijkstra " &lt;&lt; count &lt;&lt; " " &lt;&lt; max_res &lt;&lt; endl;    count = 0;    max_res = 0;    dfs(start, end, count, max_res);    cout &lt;&lt; "dfs " &lt;&lt; count &lt;&lt; " " &lt;&lt; max_res &lt;&lt; endl;    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> PAT </tag>
            
            <tag> Algorithm </tag>
            
            <tag> DFS </tag>
            
            <tag> Backtracking </tag>
            
            <tag> Dijkstra </tag>
            
            <tag> Undirected Grpha </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PAT 1002 A+B for Polynomials (25 分)</title>
      <link href="2021/03/PAT-1002-A-B-for-Polynomials-25-%E5%88%86/"/>
      <url>2021/03/PAT-1002-A-B-for-Polynomials-25-%E5%88%86/</url>
      
        <content type="html"><![CDATA[<blockquote><p>封面出处：<a href="https://www.pixiv.net/artworks/88377350">https://www.pixiv.net/artworks/88377350</a></p></blockquote><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><blockquote><p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805526272000000">1002 A+B for Polynomials (25 分)</a></p></blockquote><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>将两个多项式相加，然后按照同样的格式输出。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>建立一个<code>unordered_map</code>mapp，key为项号，value为系数，建立一个<code>vector</code>ans用于存放符合要求的项号和系数，用一个<code>int</code>high来记录最高项项号</li><li>接受第一组的输入，对应输入到mapp中去，更新high</li><li>接受第二组的输入，累加到mapp中对应的项，更新high</li><li>从high开始到0遍历，把符合要求（对应的系数不为零）的推入ans中(<code>push_back()</code>)</li><li>按照格式输出，先输出ans大小，然后输出ans各项</li></ol><h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><p><code>pair</code>的用法</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;#include &lt;unordered_map&gt;#include &lt;vector&gt;using namespace std;int main(){    unordered_map&lt;int, float&gt; mapp;    int count = 0;    int high = -1;    for(int i = 0; i &lt; 2; i++){        int n;        cin &gt;&gt; n;        for(int i = 0; i &lt; n; i++){            int k;            float v;            cin &gt;&gt; k &gt;&gt; v;            if(i == 0 &amp;&amp; high &lt; k) high = k;            mapp[k] += v;        }    }    vector&lt;pair&lt;int, float&gt;&gt; ans;    for(int i = high; i &gt;= 0; i--){        if(mapp[i] != 0.0){            ans.push_back({i, mapp[i]});        }    }    printf("%d", ans.size());    for(int i = 0; i &lt; ans.size(); i++){        printf(" %d %.1f", ans[i].first, ans[i].second);    }    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> PAT </tag>
            
            <tag> Algorithm </tag>
            
            <tag> Hash Table </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PAT 1001 A+B Format (20 分)</title>
      <link href="2021/03/PAT-1001-A-B-Format-20-%E5%88%86/"/>
      <url>2021/03/PAT-1001-A-B-Format-20-%E5%88%86/</url>
      
        <content type="html"><![CDATA[<blockquote><p>封面出处：<a href="https://www.pixiv.net/artworks/67312639">https://www.pixiv.net/artworks/67312639</a></p></blockquote><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><blockquote><p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805528788582400">1001 A+B Format (20 分)</a></p></blockquote><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>将输入的两数求和，输出指定格式（每三位添加一个<code>,</code>分隔符）</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>获得a+b之和数字的字符串c（<code>to_string()</code>)</li><li>从后往前将c中字符添加到答案字母串尾部，逢3添加一个<code>,</code>,但当已经是c的头部或者前面的字符是<code>-</code>时不添加（<code>push_back()</code>）</li><li>将答案字符串倒置并输出（<code>reverse()</code>)</li></ol><h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><p>题目给出条件是<code>−10^6≤a,b≤10^​6</code>，这样的情况下不会超出<code>int</code>的范围(<code>-2^31~2^31-1</code>)，在其他题目中仍需考虑到可能的溢出情况。</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;int main(){    int a, b;    scanf("%d %d", &amp;a, &amp;b);    string c = to_string(a + b);    string ans;    int count = 0;    for(int i = c.size()-1; i &gt;= 0; i--){        ans.push_back(c[i]);        count++;        if(count == 3 &amp;&amp; i != 0 &amp;&amp; c[i-1] != '-'){            ans.push_back(',');            count = 0;        }    }    reverse(ans.begin(), ans.end());    cout &lt;&lt; ans &lt;&lt; endl;    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> String </tag>
            
            <tag> C++ </tag>
            
            <tag> PAT </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021 完成列表</title>
      <link href="2021/01/Completed-List-2021/"/>
      <url>2021/01/Completed-List-2021/</url>
      
        <content type="html"><![CDATA[<blockquote><p>封面出处：<a href="https://www.pixiv.net/artworks/67312639">https://www.pixiv.net/artworks/67312639</a></p></blockquote><h2 id="Book"><a href="#Book" class="headerlink" title="Book"></a>Book</h2><ul><li><input checked="" disabled="" type="checkbox"> 李笑来 - <a href="https://github.com/xiaolai/everyone-can-use-english">人人都能用英语</a></li><li><input checked="" disabled="" type="checkbox"> 李笑来 - <a href="https://github.com/xiaolai/time-as-a-friend">把时间当作朋友</a></li><li><input checked="" disabled="" type="checkbox"> 李笑来 - <a href="https://github.com/selfteaching/the-craft-of-selfteaching/tree/master/markdown">自学是门手艺</a></li><li><input checked="" disabled="" type="checkbox"> 尼尔·波兹曼 - <a href="https://book.douban.com/subject/1062193/">娱乐至死</a></li></ul><h2 id="Anime"><a href="#Anime" class="headerlink" title="Anime"></a>Anime</h2><ul><li><input disabled="" type="checkbox"> SILVER LINK. - <a href="https://bgm.tv/subject/282684">のんのんびより のんすとっぷ</a></li><li><input disabled="" type="checkbox"> ufotable - <a href="https://bgm.tv/subject/245665">鬼滅の刃</a></li><li><input checked="" disabled="" type="checkbox"> WIT STUDIO - <a href="https://bgm.tv/subject/118335">進撃の巨人 Season 2</a></li><li><input checked="" disabled="" type="checkbox"> WIT STUDIO - <a href="https://bgm.tv/subject/217300">進撃の巨人 Season 3</a></li><li><input checked="" disabled="" type="checkbox"> WIT STUDIO - <a href="https://bgm.tv/subject/263750">進撃の巨人 Season 3 Part.2</a></li></ul><h2 id="Movie"><a href="#Movie" class="headerlink" title="Movie"></a>Movie</h2><ul><li><input checked="" disabled="" type="checkbox"> 水島努/P.A.WORKS - <a href="https://bgm.tv/subject/244761">劇場版 SHIROBAKO</a></li><li><input checked="" disabled="" type="checkbox"> 陈思诚 - <a href="https://movie.douban.com/subject/27619748//">唐人街探案3</a></li></ul><h2 id="Game"><a href="#Game" class="headerlink" title="Game"></a>Game</h2><ul><li><input checked="" disabled="" type="checkbox"> CD PROJEKT RED - <a href="https://www.gog.com/game/cyberpunk_2077">Cyberpunk 2077</a></li><li><input disabled="" type="checkbox"> Supergiant Games - <a href="https://store.steampowered.com/app/1145360/Hades/">Hades</a></li><li><input checked="" disabled="" type="checkbox"> SEGA - <a href="https://store.steampowered.com/app/927380/Yakuza_Kiwami_2/">龍が如く 極2</a></li><li><input checked="" disabled="" type="checkbox"> SEGA - <a href="https://store.steampowered.com/app/1088710/Yakuza_3_Remastered/">龍が如く 3 Remastered</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Memo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Comic </tag>
            
            <tag> Game </tag>
            
            <tag> Anime </tag>
            
            <tag> Book </tag>
            
            <tag> Moive </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>创建此博客的备注</title>
      <link href="2021/01/remarks-about-this-blog/"/>
      <url>2021/01/remarks-about-this-blog/</url>
      
        <content type="html"><![CDATA[<h2 id="创建博客的目的"><a href="#创建博客的目的" class="headerlink" title="创建博客的目的"></a>创建博客的目的</h2><p>通过写作更好地理解知识、技能，记录学习历程，分享学习心得，供人参考。</p><h3 id="博客主要的内容"><a href="#博客主要的内容" class="headerlink" title="博客主要的内容"></a>博客主要的内容</h3><ul><li>计算机相关</li><li>外语学习相关</li><li>随笔？</li><li>一切我感兴趣的内容</li></ul><h3 id="博客需要规范的内容"><a href="#博客需要规范的内容" class="headerlink" title="博客需要规范的内容"></a>博客需要规范的内容</h3><ul><li>tag和categories都统一采用英文</li></ul><h2 id="建立博客用到的技术"><a href="#建立博客用到的技术" class="headerlink" title="建立博客用到的技术"></a>建立博客用到的技术</h2><p>此博客目前通过<a href="https://github.com/hexojs/hexo"><code>Hexo</code></a>框架构建，采用<a href="https://github.com/blinkfox/hexo-theme-matery"><code>matery</code></a>主题，搭建在Github Page上。</p><h3 id="对主题进行了一些修改"><a href="#对主题进行了一些修改" class="headerlink" title="对主题进行了一些修改"></a>对主题进行了一些修改</h3><ul><li>关掉了部分效果，调整了颜色</li><li>layout/_partial/bg-cover-content.ejs中给打字特效增加了修改了<code>string</code>行</li></ul>]]></content>
      
      
      <categories>
          
          <category> Memo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Blog </tag>
            
            <tag> Hexo </tag>
            
            <tag> HTML </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
